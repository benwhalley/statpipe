#!/usr/bin/python

"""
Command line tool which accepts Stata commands, executes them, and returns text output.
"""
import os
import stat
import json
import subprocess
import sys
from hashlib import sha1
from clint import arguments
args = arguments.Args()

DEFAULT_STATA_EXECUTABLE = "/Applications/Stata/Stata.app/Contents/MacOS/Stata"

def statpipe():
    # make a statpipe config file to store preferences
    statrc = os.path.expanduser('.statrc')
    quiet = "-q" in args.all

    try:
        prefs = json.loads(open(statrc).read())
    except IOError:
        print "No config file found, writing defaults to %s\n" % (statrc,)
        prefs = {
            'STATA_EXECUTABLE': DEFAULT_STATA_EXECUTABLE
        }
        open(statrc, "w").write(json.dumps(prefs))

    # complain if we can't find Stata itself
    if not os.path.isfile(prefs['STATA_EXECUTABLE']):
        raise Exception("Stata executable not found at {}. Try editing ~/.statrc to tell me where it is.".format(prefs['STATA_EXECUTABLE']))

    # make a local .statpipe directory to store output to enable debugging
    if not os.path.isdir(".statpipe"):
        os.mkdir(".statpipe")
    os.chdir(".statpipe")

    # decide what to run
    if "-c" in args.all:
        code = args.all[-1]
    elif args.files:
        code = "\n\n".join((open(i, 'r').read() for i in args.files))
    else:
        code = clint.piped_in()
    if not code:
        code = "\n".join(raw_input("Enter a stata expression (e.g. di 2*2):\n").split(";"))


    # save the temporary files under a hash of the code so we can cache things
    codehash = sha1(code).hexdigest()
    tmpdo = "{}.do".format(codehash)
    tmplog = "{}.log".format(codehash)


    if not os.path.exists(tmplog):
        not quiet and sys.stderr.write("Running code now\n")
        with open(tmpdo, 'w') as f:
            f.write(code + "\n")
        result = subprocess.check_output([prefs['STATA_EXECUTABLE'], "-q", "-b", "-e", "do", tmpdo])
    else:
        not quiet and sys.stderr.write("Cached output re-used\n")

    with open(tmplog, 'r') as f:
        # delete some crufty extra space
        log = "".join(f.readlines()[2:-3])

    sys.stdout.write(log)

    return 0


if __name__ == "__main__":
    statpipe()
